using NaughtyAttributes;
using NeoFPS;
using NeoFPS.Constants;
using ProceduralToolkit;
using ProceduralToolkit.Buildings;
using TMPro;
using UnityEngine;
using UnityEngine.Serialization;

namespace RogueWave.Procedural
{
    public class BuildingGeneratorComponent : MonoBehaviour
    {
        [Header("Building Configurations")]
        [SerializeField, Tooltip("If true then a new building will be generated on Awake.")]
        private bool generateOnAwake = true;
        [SerializeField, Expandable]
        [FormerlySerializedAs("foundationPolygon")]
        private PolygonAsset[] foundationPolygons = null;
        [SerializeField, Tooltip("The number of minimum and maximum number of floors the building will have."), MinMaxSlider(2, 50)]
        internal Vector2Int floors = new Vector2Int(2, 50);
        [SerializeField, Tooltip("The parent for the building generated.")]
        private Transform parent = null;

        [Header("Planners and Constructors")]
        [SerializeField, FormerlySerializedAs("facadePlanningStrategy"), Expandable]
        private FacadePlanner facadePlanner = null;
        [SerializeField, FormerlySerializedAs("facadeConstructionStrategy"), Expandable]
        private ProceduralFacadeConstructor facadeConstructor = null;
        [SerializeField, FormerlySerializedAs("roofPlanningStrategy"), Expandable]
        private RoofPlanner roofPlanner = null;
        [SerializeField, FormerlySerializedAs("roofConstructionStrategy"), Expandable]
        private RoofConstructor roofConstructor = null;

        PolygonAsset m_foundationsPolygon;
        internal PolygonAsset foundationsPolygon
        {
            get
            {
                if (m_foundationsPolygon == null)
                {
                    m_foundationsPolygon = foundationPolygons[Random.Range(0, foundationPolygons.Length)];
                }
                return m_foundationsPolygon;
            }
        }

        private void Awake()
        {
            if (generateOnAwake)
            {
                Generate();
            }
        }

        public Transform Generate()
        {
            if (foundationsPolygon.autoGenerate)
            {
                foundationsPolygon.Randomize();
            }

            BuildingGenerator.Config config = new BuildingGenerator.Config();
            config.floors = Random.Range(floors.x, floors.y);
            
            var generator = new BuildingGenerator();
            generator.SetFacadePlanner(facadePlanner);
            generator.SetFacadeConstructor(facadeConstructor);
            generator.SetRoofPlanner(roofPlanner);
            generator.SetRoofConstructor(roofConstructor);
            config.palette = facadeConstructor.palette;
            Transform building = generator.Generate(foundationsPolygon.vertices, config, parent);

            parent.name = $"Model (Foundations generated by {foundationsPolygon})";

            for (int i = parent.childCount - 1; i >= 0; i--)
            {
                parent.GetChild(i).gameObject.isStatic = true;
                CreateColliders(parent.GetChild(i));
                AddDamageHandlers(parent.GetChild(i));
            }

            // Set UVs and colours
            MeshFilter[] meshFilters = building.GetComponentsInChildren<MeshFilter>();
            foreach (MeshFilter meshFilter in meshFilters)
            {
                Mesh mesh = meshFilter.sharedMesh;
                if (mesh == null)
                {
                    Debug.LogWarning($"Mesh filter in building generator has no mesh. The Building generator prefab has probably been saved with some mesh data in it. Stripping now, but you should remove it from the prefab to avoid this warning.");
                    Destroy(meshFilter.gameObject);
                    continue;
                }
                Vector3[] vertices = mesh.vertices;
                Vector2[] uvs = new Vector2[vertices.Length];

                for (int i = 0; i < uvs.Length; i++)
                {
                    uvs[i] = new Vector2(0, vertices[i].y / mesh.bounds.size.y);
                }

                mesh.uv = uvs;
            }

            return building;
        }

        void AddDamageHandlers(Transform building)
        {
            building.gameObject.AddComponent<BasicDamageHandler>();
            BuildingSurface surface = building.gameObject.AddComponent<BuildingSurface>();
            surface.Surface = facadeConstructor.surface;
        }

        void CreateColliders(Transform model)
        {
            MeshCollider meshCollider = model.GetComponent<MeshCollider>();

            if (meshCollider == null)
            {
                meshCollider = model.gameObject.AddComponent<MeshCollider>();
            }

            Mesh mesh = model.GetComponent<MeshFilter>().sharedMesh;
            meshCollider.sharedMesh = null;
            meshCollider.sharedMesh = mesh;
        }

#if UNITY_EDITOR
        [Button("Generate Building")]
        void GenerateBuilding()
        {
            DestroyBuilding();
            Generate();
        }

        [Button("Destroy Building")]
        void DestroyBuilding()
        {
            if (parent.childCount == 0)
            {
                return;
            }

            for (int i = parent.childCount - 1; i >= 0; i--)
            {
                Transform building = parent.GetChild(i);
                if (Application.isPlaying)
                    building.GetComponentInParent<BasicDamageHandler>().AddDamage(10000);
                else
                    DestroyImmediate(building.gameObject);
            }
        }
#endif
    }
}
